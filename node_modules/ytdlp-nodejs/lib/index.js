"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const child_process_1 = require("child_process");
const install_1 = require("./install");
const formatText_1 = __importDefault(require("./formatText"));
const stream_1 = require("stream");
const events_1 = __importDefault(require("events"));
const EmitterEvent_1 = __importDefault(require("./EmitterEvent"));
const fs_1 = __importDefault(require("fs"));
const helper_1 = require("./helper");
const schema_1 = require("./schema");
const path_1 = __importDefault(require("path"));
class _Download {
    constructor(url, options) {
        var _a;
        this.url = url;
        this.options = options;
        this.formatText = (0, formatText_1.default)(options);
        this.eventEmitter = new events_1.default();
        this.on = this.eventEmitter.on;
        this.emit = this.eventEmitter.emit;
        this.listenerCount = this.eventEmitter.listenerCount;
        this.downloadProcess(this.url, this.formatText, (_a = this.options) === null || _a === void 0 ? void 0 : _a.output);
    }
    downloadProcess(url, formatText, output) {
        var _a;
        const outputStr = this.getOutput(output);
        let newFormatText;
        if (((_a = this.options) === null || _a === void 0 ? void 0 : _a.filter) === "extractaudio") {
            newFormatText = [...formatText.split(" ")];
        }
        else {
            newFormatText = ["-f", ...formatText.split(" ")];
        }
        const downloadProcess = (0, child_process_1.spawn)(install_1.ytdlpPath, [
            url,
            "-o",
            outputStr,
            ...newFormatText,
            "--progress-template",
            helper_1.PROGRESS_STRING,
            "--ffmpeg-location",
            install_1.ffmpegPath,
        ]);
        let prevTime;
        downloadProcess.stdout.on("data", (data) => {
            const dataStr = Buffer.from(data).toString();
            if (dataStr.includes("brightest")) {
                if (!prevTime) {
                    prevTime = Date.now();
                }
                const pObj = JSON.parse(dataStr.split("-")[1]);
                if (pObj.status === "finished") {
                    const fObj = {
                        status: "finished",
                        time: (Date.now() - prevTime) / 1000,
                        time_str: (0, helper_1.secondsToHms)((Date.now() - prevTime) / 1000),
                        size: pObj.total,
                        size_str: (0, helper_1.formatBytes)(pObj.total),
                    };
                    this.emit("finished", fObj);
                    return;
                }
                pObj.percent_str = `${(0, helper_1.percentage)(pObj.downloaded, pObj.total).toFixed(2)}%`;
                pObj.downloaded_str = (0, helper_1.formatBytes)(pObj.downloaded);
                pObj.total_str = (0, helper_1.formatBytes)(pObj.total);
                pObj.speed_str = `${(0, helper_1.formatBytes)(pObj.speed)}/s`;
                pObj.eta_str = (0, helper_1.secondsToHms)(pObj.eta);
                this.emit("progress", pObj);
            }
        });
        downloadProcess.stderr.on("data", (err) => {
            const errStr = Buffer.from(err).toString();
            throw new Error(errStr);
        });
    }
    getOutput(output) {
        let outputStr = "";
        if (!output || output == "default") {
            return "%(title)s.%(ext)s";
        }
        const check = schema_1.outputType.safeParse(output);
        if (!check.success) {
            const errorObj = check.error.issues[0];
            const errorText = `${errorObj.path} type error, ${errorObj.message}`;
            throw new TypeError(errorText);
        }
        const extReg = /(\.aac|\.flac|\.mp3|\.m4a|\.opus|\.vorbis|\.wav\.mkv|\.mp4|\.ogg|\.webm|\.flv)$/g;
        if (typeof output === "string") {
            // outputStr = output;
            if (fs_1.default.lstatSync(output).isDirectory()) {
                outputStr = path_1.default.join(output, "%(title)s.%(ext)s");
            }
            else if (extReg.test(output)) {
                if (!fs_1.default.existsSync(path_1.default.dirname(output))) {
                    throw new Error("Output path not valid");
                }
            }
        }
        if (typeof output === "object") {
            let newObj = {
                outDir: "",
                filename: "",
            };
            if (!fs_1.default.existsSync(output.outDir)) {
                throw new Error("Output directory not valid");
            }
            else {
                newObj.outDir = output.outDir;
            }
            if (output.fileName) {
                if (extReg.test(output.fileName)) {
                    newObj.filename = output.fileName;
                }
                else {
                    throw new Error("File name not valid");
                }
            }
            outputStr = path_1.default.join(newObj.outDir, newObj.filename ? newObj.filename : "%(title)s.%(ext)s");
        }
        return outputStr ? outputStr : "%(title)s.%(ext)s";
    }
}
class Download extends EmitterEvent_1.default {
    constructor(url, options) {
        var _a;
        super();
        this.url = url;
        this.options = options;
        try {
            this.formatText = (0, formatText_1.default)(options);
            this.downloadProcess(this.url, this.formatText, (_a = this.options) === null || _a === void 0 ? void 0 : _a.output);
        }
        catch (error) {
            setTimeout(() => {
                this.emit("error", error);
            }, 1);
        }
    }
    downloadProcess(url, formatText, output) {
        var _a;
        const outputStr = this.getOutput(output);
        let newFormatText;
        if (((_a = this.options) === null || _a === void 0 ? void 0 : _a.filter) === "extractaudio") {
            newFormatText = [...formatText.split(" ")];
        }
        else {
            newFormatText = ["-f", ...formatText.split(" ")];
        }
        const downloadProcess = (0, child_process_1.spawn)(install_1.ytdlpPath, [
            url,
            "-o",
            outputStr,
            ...newFormatText,
            "--progress-template",
            helper_1.PROGRESS_STRING,
            "--ffmpeg-location",
            install_1.ffmpegPath,
        ]);
        let prevTime;
        downloadProcess.stdout.on("data", (data) => {
            const dataStr = Buffer.from(data).toString();
            if (dataStr.includes("brightest")) {
                if (!prevTime) {
                    prevTime = Date.now();
                }
                const pObj = JSON.parse(dataStr.split("-")[1]);
                if (pObj.status === "finished") {
                    const fObj = {
                        status: "finished",
                        time: (Date.now() - prevTime) / 1000,
                        time_str: (0, helper_1.secondsToHms)((Date.now() - prevTime) / 1000),
                        size: pObj.total,
                        size_str: (0, helper_1.formatBytes)(pObj.total),
                    };
                    this.emit("finished", fObj);
                    return;
                }
                pObj.percent_str = `${(0, helper_1.percentage)(pObj.downloaded, pObj.total).toFixed(2)}%`;
                pObj.downloaded_str = (0, helper_1.formatBytes)(pObj.downloaded);
                pObj.total_str = (0, helper_1.formatBytes)(pObj.total);
                pObj.speed_str = `${(0, helper_1.formatBytes)(pObj.speed)}/s`;
                pObj.eta_str = (0, helper_1.secondsToHms)(pObj.eta);
                this.emit("progress", pObj);
            }
        });
        downloadProcess.stderr.on("data", (err) => {
            const errStr = Buffer.from(err).toString();
            throw new Error(errStr);
        });
    }
    getOutput(output) {
        let outputStr = "";
        if (!output || output == "default") {
            return "%(title)s %(height)sp .%(ext)s";
        }
        const check = schema_1.outputType.safeParse(output);
        if (!check.success) {
            const errorObj = check.error.issues[0];
            const errorText = `${errorObj.path} type error, ${errorObj.message}`;
            throw new TypeError(errorText);
        }
        const extReg = /(\.aac|\.flac|\.mp3|\.m4a|\.opus|\.vorbis|\.wav\.mkv|\.mp4|\.ogg|\.webm|\.flv)$/g;
        if (typeof output === "string") {
            // outputStr = output;
            if (fs_1.default.lstatSync(output).isDirectory()) {
                outputStr = path_1.default.join(output, "%(title)s %(height)sp .%(ext)s");
            }
            else if (extReg.test(output)) {
                if (!fs_1.default.existsSync(path_1.default.dirname(output))) {
                    throw new Error("Output path not valid");
                }
            }
        }
        if (typeof output === "object") {
            let newObj = {
                outDir: "",
                filename: "",
            };
            if (!fs_1.default.existsSync(output.outDir)) {
                throw new Error("Output directory not valid");
            }
            else {
                newObj.outDir = output.outDir;
            }
            if (output.fileName) {
                if (extReg.test(output.fileName)) {
                    newObj.filename = output.fileName;
                }
                else {
                    throw new Error("File name not valid");
                }
            }
            outputStr = path_1.default.join(newObj.outDir, newObj.filename
                ? newObj.filename
                : "%(title)s %(height)sp .%(ext)s");
        }
        return outputStr ? outputStr : "%(title)s %(height)sp .%(ext)s";
    }
}
function download(url, options) {
    return new Download(url, options);
}
class GetStream extends EmitterEvent_1.default {
    constructor(url, options) {
        super();
        this.url = url;
        this.options = options;
        this.passThrough = new stream_1.PassThrough();
        this.pipe = (destination, options) => {
            this.passThrough.pipe(destination, options);
        };
        try {
            this.formatText = (0, formatText_1.default)(options);
            this.getStream(url, this.formatText);
        }
        catch (error) {
            setTimeout(() => {
                this.emit("error", error);
            }, 1);
        }
    }
    getStream(url, formatText) {
        const streamProcess = (0, child_process_1.spawn)(install_1.ytdlpPath, [
            url,
            "-o",
            "-",
            "-f",
            ...formatText.split(" "),
            "--progress-template",
            helper_1.PROGRESS_STRING,
            "--ffmpeg-location",
            install_1.ffmpegPath,
        ]);
        let prevTime;
        streamProcess.stderr.on("data", (err) => {
            const errStr = Buffer.from(err).toString();
            if (errStr.includes("brightest")) {
                if (!prevTime) {
                    prevTime = Date.now();
                }
                const pObj = JSON.parse(errStr.split("-")[1]);
                if (pObj.status === "finished") {
                    const fObj = {
                        status: "finished",
                        time: (Date.now() - prevTime) / 1000,
                        time_str: (0, helper_1.secondsToHms)((Date.now() - prevTime) / 1000),
                        size: pObj.total,
                        size_str: (0, helper_1.formatBytes)(pObj.total),
                    };
                    this.emit("finished", fObj);
                    return;
                }
                pObj.percent_str = `${(0, helper_1.percentage)(pObj.downloaded, pObj.total).toFixed(2)}%`;
                pObj.downloaded_str = (0, helper_1.formatBytes)(pObj.downloaded);
                pObj.total_str = (0, helper_1.formatBytes)(pObj.total);
                pObj.speed_str = `${(0, helper_1.formatBytes)(pObj.speed)}/s`;
                pObj.eta_str = (0, helper_1.secondsToHms)(pObj.eta);
                this.emit("progress", pObj);
            }
            if (errStr.includes("ERROR")) {
                this.emit("error", new Error(errStr));
            }
        });
        streamProcess.stdout.pipe(this.passThrough);
    }
}
function stream(url, options) {
    return new GetStream(url, options);
}
// function getStream(url: string, options?: FormatOptions) {
//     if (!validateUrl(url.trim())) throw new Error("Url not valid");
//     const formatText = getFormatText(options);
//     const fileStream = new PassThrough();
//     const streamProcess = spawn(ytdlpPath, [
//         url,
//         "-o",
//         "-",
//         "-f",
//         formatText,
//         "--progress-template",
//         PROGRESS_STRING,
//     ]);
//     let prevTime: any;
//     streamProcess.stderr.on("data", (err) => {
//         const errStr = Buffer.from(err).toString();
//         if (errStr.includes("brightest")) {
//             if (!prevTime) {
//                 prevTime = Date.now();
//             }
//             const pObj = JSON.parse(errStr.split("-")[1]);
//             if (pObj.status === "finished") {
//                 const fObj = {
//                     status: "finished",
//                     time: (Date.now() - prevTime) / 1000,
//                     time_str: secondsToHms((Date.now() - prevTime) / 1000),
//                     size: pObj.total,
//                     size_str: formatBytes(pObj.total),
//                 };
//                 fileStream.emit("finished", fObj);
//                 return;
//             }
//             pObj.percent_str = `${percentage(
//                 pObj.downloaded,
//                 pObj.total
//             ).toFixed(2)}%`;
//             pObj.downloaded_str = formatBytes(pObj.downloaded);
//             pObj.total_str = formatBytes(pObj.total);
//             pObj.speed_str = `${formatBytes(pObj.speed)}/s`;
//             pObj.eta_str = secondsToHms(pObj.eta);
//             fileStream.emit("progress", pObj);
//         }
//     });
//     streamProcess.stdout.pipe(fileStream);
//     return fileStream;
// }
function getFormats(url) {
    return new Promise(function (resolve, reject) {
        if (!validateUrl(url.trim()))
            reject(new Error("Url not valid"));
        const newUrl = normalizeUrl(url);
        const getFormatsProcess = (0, child_process_1.spawn)(install_1.ytdlpPath, [newUrl, "-J"]);
        getFormatsProcess.stderr.on("data", (err) => {
            const errStr = Buffer.from(err).toString();
            reject(new Error(errStr));
        });
        getFormatsProcess.stdout.on("data", (data) => {
            const dataStr = Buffer.from(data).toString();
            const dataObj = JSON.parse(dataStr);
            if (dataObj) {
                const formats = dataObj.formats;
                resolve(formats);
            }
            else {
                reject(new Error("Something went wrong!"));
            }
        });
    });
}
function getInfo(url) {
    return new Promise(function (resolve, reject) {
        if (!validateUrl(url.trim()))
            reject(new Error("Url not valid"));
        const newUrl = normalizeUrl(url);
        const getInfoProcess = (0, child_process_1.spawn)(install_1.ytdlpPath, [newUrl, "-J"]);
        getInfoProcess.stderr.on("data", (err) => {
            const errStr = Buffer.from(err).toString();
            reject(new Error(errStr));
        });
        getInfoProcess.stdout.on("data", (data) => {
            const dataStr = Buffer.from(data).toString();
            const dataObj = JSON.parse(dataStr);
            resolve(dataObj);
        });
    });
}
function getThumbnails(url, { quality = "default", type = "jpg" } = {
    quality: "default",
    type: "jpg",
}) {
    if (!validateUrl(url)) {
        throw Error("Url not valid!");
    }
    const videoId = getVideoId(url);
    if (!videoId) {
        throw Error("video Id not valid!");
    }
    switch (quality) {
        case "max":
            return `https://i1.ytimg.com/vi${type === "webp" ? "_webp" : ""}/${videoId}/maxresdefault.${type}`;
        case "hq":
            return `https://i1.ytimg.com/vi${type === "webp" ? "_webp" : ""}/${videoId}/mqdefault.${type}`;
        case "mq":
            return `https://i1.ytimg.com/vi${type === "webp" ? "_webp" : ""}/${videoId}/hqdefault.${type}`;
        case "sd":
            return `https://i1.ytimg.com/vi${type === "webp" ? "_webp" : ""}/${videoId}/sddefault.${type}`;
        case "default":
            return `https://i1.ytimg.com/vi${type === "webp" ? "_webp" : ""}/${videoId}/default.${type}`;
        default:
            return "Please provide proper input for quality (max,hq,mq,sd,default)";
    }
}
function normalizeUrl(url) {
    if (!validateUrl(url.trim()))
        throw new Error("Url not valid");
    const parsed = new URL(url.trim());
    const isVideo = parsed.searchParams.get("v");
    const isPlaylist = parsed.searchParams.get("list");
    if (isVideo) {
        return isVideo;
    }
    else if (isPlaylist) {
        return isPlaylist;
    }
    else {
        throw new Error("Url couldn't normalize");
    }
}
function getVideoId(url) {
    if (!validateUrl(url.trim()))
        throw new Error("Url not valid");
    const parsed = new URL(url);
    const videoId = parsed.searchParams.get("v");
    if (!videoId)
        throw new Error("This is not Video url");
    return videoId;
}
function getPlaylistId(url) {
    if (!validateUrl(url.trim()))
        throw new Error("Url not valid");
    const parsed = new URL(url);
    const listId = parsed.searchParams.get("list");
    if (!listId)
        throw new Error("This is not playlist url");
    return listId;
}
function validateId(id) {
    const videoRegex = /^[a-zA-Z0-9-_]{11}$/;
    const playlistRegex = /^[a-zA-Z0-9-_]{34}$/;
    if (videoRegex.test(id.trim()) || playlistRegex.test(id.trim())) {
        return true;
    }
    else {
        return false;
    }
}
function validateUrl(url) {
    const parsed = new URL(url.trim());
    const urlRegex = /https:\/\/www.youtube.com\/(playlist|watch|shorts)(\?|\/)/g;
    const checkUrl = urlRegex.test(parsed.toString());
    if (!checkUrl)
        return false;
    const isVideo = parsed.searchParams.get("v");
    const isPlaylist = parsed.searchParams.get("list");
    if (isVideo || isPlaylist) {
        return true;
    }
    else {
        return false;
    }
}
module.exports = {
    validateId,
    validateUrl,
    getInfo,
    getPlaylistId,
    getVideoId,
    getThumbnails,
    getFormats,
    stream,
    download,
    isInstalled: !(0, install_1.isNotInstalled)(),
    isNotInstalled: (0, install_1.isNotInstalled)(),
};
//# sourceMappingURL=index.js.map