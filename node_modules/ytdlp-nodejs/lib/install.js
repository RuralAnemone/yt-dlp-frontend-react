"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.install = exports.isNotInstalled = exports.ffmpegPath = exports.ytdlpPath = void 0;
const os_1 = __importDefault(require("os"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const follow_redirects_1 = require("follow-redirects");
const urls_json_1 = __importDefault(require("./urls.json"));
const cli_progress_1 = __importDefault(require("cli-progress"));
const extract_zip_1 = __importDefault(require("extract-zip"));
function getOsUrl(type) {
    if (os_1.default.platform() === "win32") {
        if (os_1.default.arch() === "x64") {
            return type === "ytdlp"
                ? urls_json_1.default.ytdlpWin64
                : type === "ffmpeg"
                    ? urls_json_1.default.ffmpegWin64
                    : "";
        }
        else if (os_1.default.arch() === "x32") {
            return type === "ytdlp"
                ? urls_json_1.default.ytdlpWin32
                : type === "ffmpeg"
                    ? urls_json_1.default.ffmpegWin32
                    : "";
        }
        else {
            console.log("Your os not supported");
            process.exit(1);
        }
    }
    else if (os_1.default.platform() === "darwin") {
        return type === "ytdlp"
            ? urls_json_1.default.ytdlpMacos
            : type === "ffmpeg"
                ? urls_json_1.default.ffmpegMacos
                : "";
    }
    else if (os_1.default.platform() === "linux") {
        return type === "ytdlp"
            ? urls_json_1.default.ytdlpLinux
            : type === "ffmpeg"
                ? urls_json_1.default.ytdlpLinux
                : "";
    }
    else {
        console.log("Your os not supported");
        process.exit(1);
    }
}
const ytdlpUrl = getOsUrl("ytdlp");
const ffmpegUrl = getOsUrl("ffmpeg");
const ytdlpPath = path_1.default.join(__dirname, "bin", path_1.default.basename(ytdlpUrl));
exports.ytdlpPath = ytdlpPath;
const ffmpegPath = path_1.default.join(__dirname, "bin", os_1.default.platform() === "win32" ? "ffmpeg.exe" : "ffmpeg");
exports.ffmpegPath = ffmpegPath;
const ffmpegZip = path_1.default.join(__dirname, "bin", path_1.default.basename(ffmpegUrl));
function install() {
    if (!fs_1.default.existsSync(path_1.default.dirname(ytdlpPath))) {
        fs_1.default.mkdirSync(path_1.default.dirname(ytdlpPath));
    }
    downloadFile(ytdlpUrl, ytdlpPath, (err) => {
        if (err) {
            return console.log("Download yt-dlp failed to some reason, Please try again");
        }
        downloadFile(ffmpegUrl, ffmpegZip, (err) => {
            if (err) {
                return console.log("Failed to download ffmpeg, Please try again");
            }
            console.log("Download Completed, Please re-run the application");
        });
    });
}
exports.install = install;
function downloadFile(url, savePath, callback) {
    const progressBar = new cli_progress_1.default.SingleBar({
        format: `Download ${path_1.default.basename(savePath)} {bar} {percentage}% | {eta_formatted} remaining...`,
    }, cli_progress_1.default.Presets.shades_classic);
    const file = fs_1.default.createWriteStream(savePath);
    let receivedBytes = 0;
    follow_redirects_1.https.get(url, (res) => {
        if (res.statusCode !== 200) {
            return callback("Response status was " + res.statusCode);
        }
        const totalBytes = res.headers["content-length"];
        progressBar.start(totalBytes ? parseInt(totalBytes) : 100, 0);
        res.on("data", (chunk) => {
            receivedBytes += chunk.length;
            progressBar.update(receivedBytes);
        });
        res.pipe(file);
        res.on("error", (err) => {
            fs_1.default.unlinkSync(savePath);
        });
    });
    file.on("finish", () => __awaiter(this, void 0, void 0, function* () {
        progressBar.stop();
        if (path_1.default.extname(savePath) === ".zip") {
            try {
                const dirname = path_1.default.dirname(savePath);
                yield (0, extract_zip_1.default)(savePath, { dir: dirname });
                fs_1.default.rmSync(savePath);
                file.close();
                callback();
            }
            catch (error) {
                file.close();
                callback(error.message);
            }
        }
        else {
            file.close();
            callback();
        }
    }));
    file.on("error", (err) => {
        fs_1.default.unlinkSync(savePath);
        progressBar.stop();
        return callback(err.message);
    });
}
function isNotInstalled() {
    return !fs_1.default.existsSync(ytdlpPath) || !fs_1.default.existsSync(ffmpegPath);
}
exports.isNotInstalled = isNotInstalled;
if (isNotInstalled()) {
    install();
}
//# sourceMappingURL=install.js.map