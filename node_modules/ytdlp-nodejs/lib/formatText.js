"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const schema_1 = require("./schema");
function default_1(options) {
    var _a, _b;
    let formatText = "";
    if (!options) {
        formatText = "best*[vcodec!=none][acodec!=none]";
    }
    if ((options === null || options === void 0 ? void 0 : options.filter) === "audioandvideo") {
        checkType(schema_1.audioandvideo, options);
        switch (options.quality) {
            case "highest":
                formatText = `b*[vcodec!=none][acodec!=none]`;
                break;
            case "lowest":
                formatText = `w*[vcodec!=none][acodec!=none]`;
                break;
            default:
                formatText = `b*[vcodec!=none][acodec!=none]`;
                break;
        }
    }
    if ((options === null || options === void 0 ? void 0 : options.filter) === "audioonly") {
        checkType(schema_1.audioonly, options);
        switch (options.quality) {
            case "highest":
                formatText = "best*[vcodec=none]";
                break;
            case "lowest":
                formatText = "worst*[vcodec=none]";
                break;
            default:
                formatText = "best*[vcodec=none]";
                break;
        }
    }
    if ((options === null || options === void 0 ? void 0 : options.filter) === "videoonly") {
        checkType(schema_1.videoonly, options);
        switch (options.quality) {
            case "highest":
                formatText = `b*[acodec=none][ext=${options.format ? options.format : "mp4"}]`;
                break;
            case "lowest":
                formatText = `w*[acodec=none][ext=${options.format ? options.format : "mp4"}]`;
                break;
            default:
                formatText = `b*[height=${(_a = options.quality) === null || _a === void 0 ? void 0 : _a.slice(0, -1)}][acodec=none][ext=${options.format ? options.format : "mp4"}]${options.defaultQuality === "highest"
                    ? "/bv*"
                    : options.defaultQuality === "lowest"
                        ? "/wv*"
                        : options.defaultQuality === "none"
                            ? ""
                            : "/bv*"}`;
                break;
        }
    }
    if ((options === null || options === void 0 ? void 0 : options.filter) === "extractaudio") {
        checkType(schema_1.extractaudio, options);
        formatText = `--extract-audio --audio-format ${options.format ? options.format : "mp3"} --audio-quality ${options.quality ? options.quality : "5"}`;
    }
    if ((options === null || options === void 0 ? void 0 : options.filter) === "mergevideo") {
        checkType(schema_1.mergevideo, options);
        switch (options.quality) {
            case "highest":
                formatText = `bv*+ba --merge-output-format ${options.format ? options.format : "mp4"}`;
                break;
            case "lowest":
                formatText = `wv*+wa --merge-output-format ${options.format ? options.format : "mp4"}`;
                break;
            default:
                formatText = `bv*${options.quality
                    ? `[height<=` + ((_b = options.quality) === null || _b === void 0 ? void 0 : _b.slice(0, -1)) + "]"
                    : ""}+ba${options.defaultQuality === "highest"
                    ? "/bv*+ba"
                    : options.defaultQuality === "lowest"
                        ? "/wv*+wa"
                        : options.defaultQuality === "none"
                            ? ""
                            : "/bv*+ba"} --merge-output-format ${options.format ? options.format : "mp4"}`;
                break;
        }
    }
    if (options && options.embedSubs) {
        formatText = `${formatText} --embed-subs`;
    }
    if (options && options.embedThumbnail) {
        formatText = `${formatText} --embed-thumbnail`;
    }
    return formatText;
}
exports.default = default_1;
function checkType(type, value) {
    const check = type.safeParse(value);
    if (!check.success) {
        const errorObj = check.error.issues[0];
        const errorText = `${errorObj.path} type error, ${errorObj.message}`;
        throw new TypeError(errorText);
    }
}
//# sourceMappingURL=formatText.js.map